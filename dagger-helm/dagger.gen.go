// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"sort"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"

	"dagger/helm/internal/dagger"

	"dagger.io/dagger/querybuilder"
	"dagger.io/dagger/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Helm) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Container      *dagger.Container
		RegistryConfig *dagger.RegistryConfig
	}
	concrete.Container = r.Container
	concrete.RegistryConfig = r.RegistryConfig
	return json.Marshal(&concrete)
}

func (r *Helm) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Container      *dagger.Container
		RegistryConfig *dagger.RegistryConfig
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Container = concrete.Container
	r.RegistryConfig = concrete.RegistryConfig
	return nil
}

func (r Chart) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Directory *dagger.Directory
		Helm      *Helm
	}
	concrete.Directory = r.Directory
	concrete.Helm = r.Helm
	return json.Marshal(&concrete)
}

func (r *Chart) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Directory *dagger.Directory
		Helm      *Helm
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Directory = concrete.Directory
	r.Helm = concrete.Helm
	return nil
}

func (r Package) MarshalJSON() ([]byte, error) {
	var concrete struct {
		File  *dagger.File
		Helm  *Helm
		Chart *Chart
	}
	concrete.File = r.File
	concrete.Helm = r.Helm
	concrete.Chart = r.Chart
	return json.Marshal(&concrete)
}

func (r *Package) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		File  *dagger.File
		Helm  *Helm
		Chart *Chart
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.File = concrete.File
	r.Helm = concrete.Helm
	r.Chart = concrete.Chart
	return nil
}

func (r Release) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Name      string
		Namespace string
		Container *dagger.Container
	}
	concrete.Name = r.Name
	concrete.Namespace = r.Namespace
	concrete.Container = r.Container
	return json.Marshal(&concrete)
}

func (r *Release) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Name      string
		Namespace string
		Container *dagger.Container
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Name = concrete.Name
	r.Namespace = concrete.Namespace
	r.Container = concrete.Container
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func convertError(rerr error) *dagger.Error {
	if gqlErr := findSingleGQLError(rerr); gqlErr != nil {
		dagErr := dag.Error(gqlErr.Message)
		if gqlErr.Extensions != nil {
			keys := make([]string, 0, len(gqlErr.Extensions))
			for k := range gqlErr.Extensions {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				val, err := json.Marshal(gqlErr.Extensions[k])
				if err != nil {
					fmt.Println("failed to marshal error value:", err)
				}
				dagErr = dagErr.WithValue(k, dagger.JSON(val))
			}
		}
		return dagErr
	}
	return dag.Error(rerr.Error())
}

func findSingleGQLError(rerr error) *gqlerror.Error {
	switch x := rerr.(type) {
	case *gqlerror.Error:
		return x
	case interface{ Unwrap() []error }:
		return nil
	case interface{ Unwrap() error }:
		return findSingleGQLError(x.Unwrap())
	default:
		return nil
	}
}
func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, convertError(rerr)); err != nil {
				fmt.Println("failed to return error:", err, "\noriginal error:", rerr)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Chart":
		switch fnName {
		case "Install":
			var parent Chart
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var atomic bool
			if inputArgs["atomic"] != nil {
				err = json.Unmarshal([]byte(inputArgs["atomic"]), &atomic)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg atomic", err))
				}
			}
			var caFile *dagger.File
			if inputArgs["caFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["caFile"]), &caFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg caFile", err))
				}
			}
			var certFile *dagger.File
			if inputArgs["certFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["certFile"]), &certFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg certFile", err))
				}
			}
			var createNamespace bool
			if inputArgs["createNamespace"] != nil {
				err = json.Unmarshal([]byte(inputArgs["createNamespace"]), &createNamespace)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg createNamespace", err))
				}
			}
			var dependencyUpdate bool
			if inputArgs["dependencyUpdate"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dependencyUpdate"]), &dependencyUpdate)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dependencyUpdate", err))
				}
			}
			var description string
			if inputArgs["description"] != nil {
				err = json.Unmarshal([]byte(inputArgs["description"]), &description)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg description", err))
				}
			}
			var disableOpenapiValidation bool
			if inputArgs["disableOpenapiValidation"] != nil {
				err = json.Unmarshal([]byte(inputArgs["disableOpenapiValidation"]), &disableOpenapiValidation)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg disableOpenapiValidation", err))
				}
			}
			var enableDns bool
			if inputArgs["enableDns"] != nil {
				err = json.Unmarshal([]byte(inputArgs["enableDns"]), &enableDns)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg enableDns", err))
				}
			}
			var force bool
			if inputArgs["force"] != nil {
				err = json.Unmarshal([]byte(inputArgs["force"]), &force)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg force", err))
				}
			}
			var generateName bool
			if inputArgs["generateName"] != nil {
				err = json.Unmarshal([]byte(inputArgs["generateName"]), &generateName)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg generateName", err))
				}
			}
			var insecureSkipTlsVerify bool
			if inputArgs["insecureSkipTlsVerify"] != nil {
				err = json.Unmarshal([]byte(inputArgs["insecureSkipTlsVerify"]), &insecureSkipTlsVerify)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg insecureSkipTlsVerify", err))
				}
			}
			var keyFile *dagger.Secret
			if inputArgs["keyFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["keyFile"]), &keyFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg keyFile", err))
				}
			}
			var labels []string
			if inputArgs["labels"] != nil {
				err = json.Unmarshal([]byte(inputArgs["labels"]), &labels)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg labels", err))
				}
			}
			var nameTemplate string
			if inputArgs["nameTemplate"] != nil {
				err = json.Unmarshal([]byte(inputArgs["nameTemplate"]), &nameTemplate)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg nameTemplate", err))
				}
			}
			var noHooks bool
			if inputArgs["noHooks"] != nil {
				err = json.Unmarshal([]byte(inputArgs["noHooks"]), &noHooks)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg noHooks", err))
				}
			}
			var plainHttp bool
			if inputArgs["plainHttp"] != nil {
				err = json.Unmarshal([]byte(inputArgs["plainHttp"]), &plainHttp)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg plainHttp", err))
				}
			}
			var postRenderer string
			if inputArgs["postRenderer"] != nil {
				err = json.Unmarshal([]byte(inputArgs["postRenderer"]), &postRenderer)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg postRenderer", err))
				}
			}
			var postRendererArgs []string
			if inputArgs["postRendererArgs"] != nil {
				err = json.Unmarshal([]byte(inputArgs["postRendererArgs"]), &postRendererArgs)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg postRendererArgs", err))
				}
			}
			var renderSubchartNotes bool
			if inputArgs["renderSubchartNotes"] != nil {
				err = json.Unmarshal([]byte(inputArgs["renderSubchartNotes"]), &renderSubchartNotes)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg renderSubchartNotes", err))
				}
			}
			var replace bool
			if inputArgs["replace"] != nil {
				err = json.Unmarshal([]byte(inputArgs["replace"]), &replace)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg replace", err))
				}
			}
			var skipCrds bool
			if inputArgs["skipCrds"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skipCrds"]), &skipCrds)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skipCrds", err))
				}
			}
			var timeout string
			if inputArgs["timeout"] != nil {
				err = json.Unmarshal([]byte(inputArgs["timeout"]), &timeout)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg timeout", err))
				}
			}
			var values []*dagger.File
			if inputArgs["values"] != nil {
				err = json.Unmarshal([]byte(inputArgs["values"]), &values)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg values", err))
				}
			}
			var verify bool
			if inputArgs["verify"] != nil {
				err = json.Unmarshal([]byte(inputArgs["verify"]), &verify)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg verify", err))
				}
			}
			var wait bool
			if inputArgs["wait"] != nil {
				err = json.Unmarshal([]byte(inputArgs["wait"]), &wait)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg wait", err))
				}
			}
			var waitForJobs bool
			if inputArgs["waitForJobs"] != nil {
				err = json.Unmarshal([]byte(inputArgs["waitForJobs"]), &waitForJobs)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg waitForJobs", err))
				}
			}
			var namespace string
			if inputArgs["namespace"] != nil {
				err = json.Unmarshal([]byte(inputArgs["namespace"]), &namespace)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg namespace", err))
				}
			}
			return (*Chart).Install(&parent, ctx, name, atomic, caFile, certFile, createNamespace, dependencyUpdate, description, disableOpenapiValidation, enableDns, force, generateName, insecureSkipTlsVerify, keyFile, labels, nameTemplate, noHooks, plainHttp, postRenderer, postRendererArgs, renderSubchartNotes, replace, skipCrds, timeout, values, verify, wait, waitForJobs, namespace)
		case "Lint":
			var parent Chart
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Chart).Lint(&parent, ctx)
		case "Package":
			var parent Chart
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var appVersion string
			if inputArgs["appVersion"] != nil {
				err = json.Unmarshal([]byte(inputArgs["appVersion"]), &appVersion)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg appVersion", err))
				}
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			var dependencyUpdate bool
			if inputArgs["dependencyUpdate"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dependencyUpdate"]), &dependencyUpdate)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dependencyUpdate", err))
				}
			}
			return (*Chart).Package(&parent, ctx, appVersion, version, dependencyUpdate)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "Helm":
		switch fnName {
		case "Chart":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var source *dagger.Directory
			if inputArgs["source"] != nil {
				err = json.Unmarshal([]byte(inputArgs["source"]), &source)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg source", err))
				}
			}
			return (*Helm).Chart(&parent, source), nil
		case "Create":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			return (*Helm).Create(&parent, name), nil
		case "Lint":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var chart *dagger.Directory
			if inputArgs["chart"] != nil {
				err = json.Unmarshal([]byte(inputArgs["chart"]), &chart)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg chart", err))
				}
			}
			return (*Helm).Lint(&parent, ctx, chart)
		case "Login":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var host string
			if inputArgs["host"] != nil {
				err = json.Unmarshal([]byte(inputArgs["host"]), &host)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg host", err))
				}
			}
			var username string
			if inputArgs["username"] != nil {
				err = json.Unmarshal([]byte(inputArgs["username"]), &username)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg username", err))
				}
			}
			var password *dagger.Secret
			if inputArgs["password"] != nil {
				err = json.Unmarshal([]byte(inputArgs["password"]), &password)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg password", err))
				}
			}
			var insecure bool
			if inputArgs["insecure"] != nil {
				err = json.Unmarshal([]byte(inputArgs["insecure"]), &insecure)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg insecure", err))
				}
			}
			return (*Helm).Login(&parent, ctx, host, username, password, insecure), nil
		case "Logout":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var host string
			if inputArgs["host"] != nil {
				err = json.Unmarshal([]byte(inputArgs["host"]), &host)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg host", err))
				}
			}
			return (*Helm).Logout(&parent, host), nil
		case "Package":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var chart *dagger.Directory
			if inputArgs["chart"] != nil {
				err = json.Unmarshal([]byte(inputArgs["chart"]), &chart)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg chart", err))
				}
			}
			var appVersion string
			if inputArgs["appVersion"] != nil {
				err = json.Unmarshal([]byte(inputArgs["appVersion"]), &appVersion)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg appVersion", err))
				}
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			var dependencyUpdate bool
			if inputArgs["dependencyUpdate"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dependencyUpdate"]), &dependencyUpdate)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dependencyUpdate", err))
				}
			}
			return (*Helm).Package(&parent, ctx, chart, appVersion, version, dependencyUpdate)
		case "Push":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var pkg *dagger.File
			if inputArgs["pkg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pkg"]), &pkg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pkg", err))
				}
			}
			var registry string
			if inputArgs["registry"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registry"]), &registry)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registry", err))
				}
			}
			var plainHttp bool
			if inputArgs["plainHttp"] != nil {
				err = json.Unmarshal([]byte(inputArgs["plainHttp"]), &plainHttp)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg plainHttp", err))
				}
			}
			var insecureSkipTlsVerify bool
			if inputArgs["insecureSkipTlsVerify"] != nil {
				err = json.Unmarshal([]byte(inputArgs["insecureSkipTlsVerify"]), &insecureSkipTlsVerify)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg insecureSkipTlsVerify", err))
				}
			}
			var caFile *dagger.File
			if inputArgs["caFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["caFile"]), &caFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg caFile", err))
				}
			}
			var certFile *dagger.File
			if inputArgs["certFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["certFile"]), &certFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg certFile", err))
				}
			}
			var keyFile *dagger.Secret
			if inputArgs["keyFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["keyFile"]), &keyFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg keyFile", err))
				}
			}
			return nil, (*Helm).Push(&parent, ctx, pkg, registry, plainHttp, insecureSkipTlsVerify, caFile, certFile, keyFile)
		case "WithKubeconfigFile":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var file *dagger.File
			if inputArgs["file"] != nil {
				err = json.Unmarshal([]byte(inputArgs["file"]), &file)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg file", err))
				}
			}
			return (*Helm).WithKubeconfigFile(&parent, file), nil
		case "WithKubeconfigSecret":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var secret *dagger.Secret
			if inputArgs["secret"] != nil {
				err = json.Unmarshal([]byte(inputArgs["secret"]), &secret)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg secret", err))
				}
			}
			return (*Helm).WithKubeconfigSecret(&parent, secret), nil
		case "WithRegistryAuth":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var address string
			if inputArgs["address"] != nil {
				err = json.Unmarshal([]byte(inputArgs["address"]), &address)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg address", err))
				}
			}
			var username string
			if inputArgs["username"] != nil {
				err = json.Unmarshal([]byte(inputArgs["username"]), &username)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg username", err))
				}
			}
			var secret *dagger.Secret
			if inputArgs["secret"] != nil {
				err = json.Unmarshal([]byte(inputArgs["secret"]), &secret)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg secret", err))
				}
			}
			return (*Helm).WithRegistryAuth(&parent, address, username, secret), nil
		case "WithoutRegistryAuth":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var address string
			if inputArgs["address"] != nil {
				err = json.Unmarshal([]byte(inputArgs["address"]), &address)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg address", err))
				}
			}
			return (*Helm).WithoutRegistryAuth(&parent, address), nil
		case "":
			var parent Helm
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			var container *dagger.Container
			if inputArgs["container"] != nil {
				err = json.Unmarshal([]byte(inputArgs["container"]), &container)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg container", err))
				}
			}
			return New(version, container), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "Package":
		switch fnName {
		case "Install":
			var parent Package
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var atomic bool
			if inputArgs["atomic"] != nil {
				err = json.Unmarshal([]byte(inputArgs["atomic"]), &atomic)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg atomic", err))
				}
			}
			var caFile *dagger.File
			if inputArgs["caFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["caFile"]), &caFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg caFile", err))
				}
			}
			var certFile *dagger.File
			if inputArgs["certFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["certFile"]), &certFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg certFile", err))
				}
			}
			var createNamespace bool
			if inputArgs["createNamespace"] != nil {
				err = json.Unmarshal([]byte(inputArgs["createNamespace"]), &createNamespace)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg createNamespace", err))
				}
			}
			var dependencyUpdate bool
			if inputArgs["dependencyUpdate"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dependencyUpdate"]), &dependencyUpdate)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dependencyUpdate", err))
				}
			}
			var description string
			if inputArgs["description"] != nil {
				err = json.Unmarshal([]byte(inputArgs["description"]), &description)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg description", err))
				}
			}
			var disableOpenapiValidation bool
			if inputArgs["disableOpenapiValidation"] != nil {
				err = json.Unmarshal([]byte(inputArgs["disableOpenapiValidation"]), &disableOpenapiValidation)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg disableOpenapiValidation", err))
				}
			}
			var enableDns bool
			if inputArgs["enableDns"] != nil {
				err = json.Unmarshal([]byte(inputArgs["enableDns"]), &enableDns)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg enableDns", err))
				}
			}
			var force bool
			if inputArgs["force"] != nil {
				err = json.Unmarshal([]byte(inputArgs["force"]), &force)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg force", err))
				}
			}
			var generateName bool
			if inputArgs["generateName"] != nil {
				err = json.Unmarshal([]byte(inputArgs["generateName"]), &generateName)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg generateName", err))
				}
			}
			var insecureSkipTlsVerify bool
			if inputArgs["insecureSkipTlsVerify"] != nil {
				err = json.Unmarshal([]byte(inputArgs["insecureSkipTlsVerify"]), &insecureSkipTlsVerify)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg insecureSkipTlsVerify", err))
				}
			}
			var keyFile *dagger.Secret
			if inputArgs["keyFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["keyFile"]), &keyFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg keyFile", err))
				}
			}
			var labels []string
			if inputArgs["labels"] != nil {
				err = json.Unmarshal([]byte(inputArgs["labels"]), &labels)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg labels", err))
				}
			}
			var nameTemplate string
			if inputArgs["nameTemplate"] != nil {
				err = json.Unmarshal([]byte(inputArgs["nameTemplate"]), &nameTemplate)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg nameTemplate", err))
				}
			}
			var noHooks bool
			if inputArgs["noHooks"] != nil {
				err = json.Unmarshal([]byte(inputArgs["noHooks"]), &noHooks)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg noHooks", err))
				}
			}
			var plainHttp bool
			if inputArgs["plainHttp"] != nil {
				err = json.Unmarshal([]byte(inputArgs["plainHttp"]), &plainHttp)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg plainHttp", err))
				}
			}
			var postRenderer string
			if inputArgs["postRenderer"] != nil {
				err = json.Unmarshal([]byte(inputArgs["postRenderer"]), &postRenderer)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg postRenderer", err))
				}
			}
			var postRendererArgs []string
			if inputArgs["postRendererArgs"] != nil {
				err = json.Unmarshal([]byte(inputArgs["postRendererArgs"]), &postRendererArgs)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg postRendererArgs", err))
				}
			}
			var renderSubchartNotes bool
			if inputArgs["renderSubchartNotes"] != nil {
				err = json.Unmarshal([]byte(inputArgs["renderSubchartNotes"]), &renderSubchartNotes)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg renderSubchartNotes", err))
				}
			}
			var replace bool
			if inputArgs["replace"] != nil {
				err = json.Unmarshal([]byte(inputArgs["replace"]), &replace)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg replace", err))
				}
			}
			var skipCrds bool
			if inputArgs["skipCrds"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skipCrds"]), &skipCrds)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skipCrds", err))
				}
			}
			var timeout string
			if inputArgs["timeout"] != nil {
				err = json.Unmarshal([]byte(inputArgs["timeout"]), &timeout)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg timeout", err))
				}
			}
			var values []*dagger.File
			if inputArgs["values"] != nil {
				err = json.Unmarshal([]byte(inputArgs["values"]), &values)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg values", err))
				}
			}
			var verify bool
			if inputArgs["verify"] != nil {
				err = json.Unmarshal([]byte(inputArgs["verify"]), &verify)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg verify", err))
				}
			}
			var wait bool
			if inputArgs["wait"] != nil {
				err = json.Unmarshal([]byte(inputArgs["wait"]), &wait)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg wait", err))
				}
			}
			var waitForJobs bool
			if inputArgs["waitForJobs"] != nil {
				err = json.Unmarshal([]byte(inputArgs["waitForJobs"]), &waitForJobs)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg waitForJobs", err))
				}
			}
			var namespace string
			if inputArgs["namespace"] != nil {
				err = json.Unmarshal([]byte(inputArgs["namespace"]), &namespace)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg namespace", err))
				}
			}
			return (*Package).Install(&parent, ctx, name, atomic, caFile, certFile, createNamespace, dependencyUpdate, description, disableOpenapiValidation, enableDns, force, generateName, insecureSkipTlsVerify, keyFile, labels, nameTemplate, noHooks, plainHttp, postRenderer, postRendererArgs, renderSubchartNotes, replace, skipCrds, timeout, values, verify, wait, waitForJobs, namespace)
		case "Publish":
			var parent Package
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var registry string
			if inputArgs["registry"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registry"]), &registry)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registry", err))
				}
			}
			var plainHttp bool
			if inputArgs["plainHttp"] != nil {
				err = json.Unmarshal([]byte(inputArgs["plainHttp"]), &plainHttp)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg plainHttp", err))
				}
			}
			var insecureSkipTlsVerify bool
			if inputArgs["insecureSkipTlsVerify"] != nil {
				err = json.Unmarshal([]byte(inputArgs["insecureSkipTlsVerify"]), &insecureSkipTlsVerify)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg insecureSkipTlsVerify", err))
				}
			}
			var caFile *dagger.File
			if inputArgs["caFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["caFile"]), &caFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg caFile", err))
				}
			}
			var certFile *dagger.File
			if inputArgs["certFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["certFile"]), &certFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg certFile", err))
				}
			}
			var keyFile *dagger.Secret
			if inputArgs["keyFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["keyFile"]), &keyFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg keyFile", err))
				}
			}
			return nil, (*Package).Publish(&parent, ctx, registry, plainHttp, insecureSkipTlsVerify, caFile, certFile, keyFile)
		case "WithKubeconfigFile":
			var parent Package
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var file *dagger.File
			if inputArgs["file"] != nil {
				err = json.Unmarshal([]byte(inputArgs["file"]), &file)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg file", err))
				}
			}
			return (*Package).WithKubeconfigFile(&parent, file), nil
		case "WithKubeconfigSecret":
			var parent Package
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var secret *dagger.Secret
			if inputArgs["secret"] != nil {
				err = json.Unmarshal([]byte(inputArgs["secret"]), &secret)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg secret", err))
				}
			}
			return (*Package).WithKubeconfigSecret(&parent, secret), nil
		case "WithRegistryAuth":
			var parent Package
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var address string
			if inputArgs["address"] != nil {
				err = json.Unmarshal([]byte(inputArgs["address"]), &address)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg address", err))
				}
			}
			var username string
			if inputArgs["username"] != nil {
				err = json.Unmarshal([]byte(inputArgs["username"]), &username)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg username", err))
				}
			}
			var secret *dagger.Secret
			if inputArgs["secret"] != nil {
				err = json.Unmarshal([]byte(inputArgs["secret"]), &secret)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg secret", err))
				}
			}
			return (*Package).WithRegistryAuth(&parent, address, username, secret), nil
		case "WithoutRegistryAuth":
			var parent Package
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var address string
			if inputArgs["address"] != nil {
				err = json.Unmarshal([]byte(inputArgs["address"]), &address)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg address", err))
				}
			}
			return (*Package).WithoutRegistryAuth(&parent, address), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "Release":
		switch fnName {
		case "Test":
			var parent Release
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var filter []string
			if inputArgs["filter"] != nil {
				err = json.Unmarshal([]byte(inputArgs["filter"]), &filter)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg filter", err))
				}
			}
			var logs bool
			if inputArgs["logs"] != nil {
				err = json.Unmarshal([]byte(inputArgs["logs"]), &logs)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg logs", err))
				}
			}
			var timeout string
			if inputArgs["timeout"] != nil {
				err = json.Unmarshal([]byte(inputArgs["timeout"]), &timeout)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg timeout", err))
				}
			}
			return (*Release).Test(&parent, ctx, filter, logs, timeout)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
